{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"algorithms/Binary%20Search/","title":"Binary Search","text":"<p>I know binary search feels like a trivial algorithm, but I guess if I had to say which algo I struggled with the most despite knowing the concept, it'd be the Binary Search. The concept is clear, but I always make mistakes with where to put <code>&lt;=</code> or <code>&lt;</code>. So, here's a standard template that should work for finding a target value in a sorted array.</p>"},{"location":"algorithms/Binary%20Search/#typical-binary-search","title":"Typical Binary Search","text":"<p>There are a few key points to focus on when writing a binary search algorithm. I'll provide reasons for each, but memorizing them works as well.</p> <ol> <li> <p>Main <code>while</code> loop condition: Keep it <code>while left &lt;= right</code>.</p> <ul> <li>This ensures that the search continues as long as there is at least one element in the search space. When <code>left</code> becomes greater than <code>right</code>, it means the search space is empty.</li> </ul> </li> <li> <p>Modifying <code>left</code> and <code>right</code>: Always update <code>left</code> or <code>right</code> by 1 to shrink the search space.</p> <ul> <li>If <code>arr[mid] &lt; target</code>, the target must be in the right half, so we set <code>left = mid + 1</code>.</li> <li>If <code>arr[mid] &gt; target</code>, the target must be in the left half, so we set <code>right = mid - 1</code>.</li> </ul> </li> <li> <p>Early Exit: We can stop early if we find the target.</p> <ul> <li>If <code>arr[mid] == target</code>, we've found the element and can return <code>mid</code> immediately.</li> </ul> </li> <li> <p>Return Value:</p> <ul> <li>If the target is found, we return its index.</li> <li>If the loop finishes without finding the target.<ul> <li>After the loop finished the inequality relation will be <code>right &lt; target &lt; left</code>, i.e. right will point to largest element smaller than target and left will point to smallest element larger than the target.</li> <li>Depending on the use case we might want to return. For example, we would return <code>left</code> for insert position.</li> </ul> </li> </ul> </li> </ol> <pre><code>def binary_search(arr, target):\n    left = 0\n    right = len(arr) - 1\n\n    while left &lt;= right:\n        mid = left + (right - left) // 2  # (1)!\n\n        if arr[mid] == target:\n            return mid  # (2)!\n        elif arr[mid] &lt; target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return right  # (3)!\n</code></pre> <ol> <li>This way of calculating the middle index helps in avoiding integer overflow in languages with fixed-size integers.</li> <li>Found the target, return its index</li> <li>Target not found, will need to return left or right depending on the use case.</li> </ol>"}]}